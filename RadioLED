#include <FastLED.h>
#include <SPI.h> 
#include <RF24.h>
#include <avr/sleep.h>
#include <avr/power.h>
#include <avr/wdt.h>

#define NUM_LEDS 1
#define LED_PIN 8


CRGB leds[NUM_LEDS];
bool receivedInstruction = false;
unsigned int targetHue[1] = {0};
unsigned int currentHue[1] = {0};
unsigned long currentMillis;

RF24 radio(9,10);

const byte rxAddr[6] = "00001";

void setup()
{
  Serial.begin(9600);
  FastLED.addLeds<NEOPIXEL, LED_PIN>(leds, NUM_LEDS);
  radio.begin();
  delay(100);
  radio.setRetries(15, 15);
  radio.setPALevel(RF24_PA_MIN);
  radio.stopListening();
  radio.powerDown();

  // Set the watchdog reset bit in the MCU status register to 0.
  MCUSR &= ~(1<<WDRF);
  
  // Set WDCE and WDE bits in the watchdog control register.
  WDTCSR |= (1<<WDCE) | (1<<WDE);

  // Set watchdog clock prescaler bits to a value of 8 seconds.
  WDTCSR = (1<<WDP0) | (1<<WDP3);
  
  // Enable watchdog as interrupt only (no reset).
  WDTCSR |= (1<<WDIE);
 
}

void loop()
{
 // Sleep for 5 seconds
 goToSleep(5);

  if(masterSelection()){
   targetHue[0] = generateRandom(0,255);
   Serial.print("I am master (");
   Serial.print(targetHue[0]);
   Serial.println(")");
   setLEDColour();
   radio.powerUp();
   radio.stopListening();
   radio.openWritingPipe(rxAddr);

   int pingAttempts = generateRandom(20,30);

   for(int i=0;i<pingAttempts;i++){
    if(radio.write(targetHue,sizeof(int))){
      Serial.print(".");
    }else{
      Serial.print("x");
    }
    delay(500);
   }
   Serial.println("");
   radio.powerDown();
 }
  listenForInstruction();
}

bool masterSelection(){
  
  if(generateRandom(0,10) == 1 && !listenForInstruction()){
    return true;
  } else {
    return false;
  }
}


int generateRandom(int lower, int upper){
  int seed = seedOut(31);
  randomSeed(seed);
  return random(lower,upper);
}

bool listenForInstruction(){
  receivedInstruction = false;
  Serial.println("Listening for instruction");
  radio.powerUp();
  radio.startListening();
  radio.openReadingPipe(1,rxAddr);
  currentMillis = millis();

  while(millis() - currentMillis <= 1000){
    while(radio.available()){
      radio.read(&targetHue,sizeof(int));
      Serial.print("Received: ");
      Serial.println(targetHue[0]);
      receivedInstruction = true;
    }
  }
  
  setLEDColour();
  radio.stopListening();
  radio.powerDown();
  return receivedInstruction;
}

void setLEDColour(){
    while(currentHue[0] < targetHue[0]){
      FastLED.showColor(CHSV(currentHue[0]++,255,164));
      delay(50);
    }
    while(currentHue[0] > targetHue[0]){
      FastLED.showColor(CHSV(currentHue[0]--,255,164));
      delay(50);
    }
}



void goToSleep(int duration){
  Serial.print("Sleeping for: ");
  // Set sleep to full power down.  Only external interrupts or 
  // the watchdog timer can wake the CPU!
  set_sleep_mode(SLEEP_MODE_PWR_DOWN);
  
  // Turn off the ADC while asleep.
  power_adc_disable();
  
  // Enable sleep and enter sleep mode.
  sleep_mode();
  
  // CPU is now asleep and program execution completely halts!
  // Once awake, execution will resume at this point.
  // When awake, disable sleep mode and turn on all devices.
  
  sleep_disable();
  power_all_enable();
}

void sleep(){
  delay(1000);

  /*
  cbi(ADCSRA,ADEN); 
  set_sleep_mode(SLEEP_MODE_PWR_DOWN);
  WDTCR = 1<<WDIE | (SLEEP_TIME & 0x8)<<2 | 1<<WDE | (SLEEP_TIME & 0x7);
  sleep_mode();
  */
}

/*
ISR(WDT_vect) {
  
    WDTCR = 1<<WDCE | 1<<WDE;
    WDTCR = 0;
    sbi(ADCSRA,ADEN);
}
*/

unsigned int bitOut(void)
{
  static unsigned long firstTime=1, prev=0;
  unsigned long bit1=0, bit0=0, x=0, port=0, limit=99;
  if (firstTime)
  {
    firstTime=0;
    prev=analogRead(port);
  }
  while (limit--)
  {
    x=analogRead(port);
    bit1=(prev!=x?1:0);
    prev=x;
    x=analogRead(port);
    bit0=(prev!=x?1:0);
    prev=x;
    if (bit1!=bit0)
      break;
  }
  return bit1;
}

unsigned long seedOut(unsigned int noOfBits)
{
  // return value with 'noOfBits' random bits set
  unsigned long seed=0;
  for (int i=0;i<noOfBits;++i)
    seed = (seed<<1) | bitOut();
  return seed;
}
